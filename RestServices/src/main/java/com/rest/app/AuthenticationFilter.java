/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.rest.app;

/**
 *
 * @author RS-Kiran
 */
import java.io.IOException;
import java.security.GeneralSecurityException;
import java.util.HashMap;
import java.util.Map;
import java.util.UUID;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.security.auth.login.LoginException;
import javax.ws.rs.container.ContainerRequestContext;
import javax.ws.rs.container.ContainerRequestFilter;
import javax.ws.rs.core.Context;
import javax.ws.rs.core.HttpHeaders;
import javax.ws.rs.core.MultivaluedMap;
import javax.ws.rs.ext.Provider;


/**
 * This filter verify the access permissions for a user based on username and
 * passowrd provided in request
 *
 */
@Provider
public class AuthenticationFilter implements ContainerRequestFilter{
    
    @Context
    HttpHeaders Httpheaders;

      private static AuthenticationFilter authenticator = null;
      
      private final String SERVICE_KEY = "serviceKey";
      
      private final String USERNAME = "username";
      
      private final String PASSWORD = "password";
      
      private String serviceKey = "";
      private String authToken = "";
      private String username = "";
      private String password = "";

    // A user storage which stores <username, password>
    private final Map<String, String> usersStorage = new HashMap();

    // A service key storage which stores <service_key, username>
    private final Map<String, String> serviceKeysStorage = new HashMap();

    // An authentication token storage which stores <service_key, auth_token>.
    private final Map<String, String> authorizationTokensStorage = new HashMap();

    private AuthenticationFilter() {
        // The usersStorage pretty much represents a user table in the database
        usersStorage.put( "Admin", "Password9!" );
        usersStorage.put( "Kiran", "Kiran9!" );
        usersStorage.put( "Gangadhar", "Gangadhar9!" );

        /**
         * Service keys are pre-generated by the system and is given to the
         * authorized client who wants to have access to the REST API. Here,
         * only username1 and username2 is given the REST service access with
         * their respective service keys.
         */
        serviceKeysStorage.put( "f80ebc87-ad5c-4b29-9366-5359768df5a1", "Kiran" );
        serviceKeysStorage.put( "3b91cab8-926f-49b6-ba00-920bcf934c2a", "Admin" );
        serviceKeysStorage.put( "3b91cab8-926f-49b6-ba00-fjkwrf934c2a", "Gangadhar" );
    }

    public static AuthenticationFilter getInstance() {
        if ( authenticator == null ) {
            authenticator = new AuthenticationFilter();
        }

        return authenticator;
    }

    public String login( String serviceKey, String username, String password ) throws LoginException {
        if ( serviceKeysStorage.containsKey( serviceKey ) ) {
            String usernameMatch = serviceKeysStorage.get( serviceKey );

            if ( usernameMatch.equals( username ) && usersStorage.containsKey( username ) ) {
                String passwordMatch = usersStorage.get( username );

                if ( passwordMatch.equals( password ) ) {

                    /**
                     * Once all params are matched, the authToken will be
                     * generated and will be stored in the
                     * authorizationTokensStorage. The authToken will be needed
                     * for every REST API invocation and is only valid within
                     * the login session
                     */
                    String authToken = UUID.randomUUID().toString();
                    authorizationTokensStorage.put( authToken, username );

                    return authToken;
                }
            }
        }

        throw new LoginException( "Don't Come Here Again!" );
    }

    /**
     * The method that pre-validates if the client which invokes the REST API is
     * from a authorized and authenticated source.
     *
     * @param serviceKey The service key
     * @param authToken The authorization token generated after login
     * @return TRUE for acceptance and FALSE for denied.
     */
    public boolean isAuthTokenValid( String serviceKey, String authToken ) {
        if ( isServiceKeyValid( serviceKey ) ) {
            String usernameMatch1 = serviceKeysStorage.get( serviceKey );

            if ( authorizationTokensStorage.containsKey( authToken ) ) {
                String usernameMatch2 = authorizationTokensStorage.get( authToken );

                if ( usernameMatch1.equals( usernameMatch2 ) ) {
                    return true;
                }
            }
        }

        return false;
    }

    /**
     * This method checks is the service key is valid
     *
     * @param serviceKey
     * @return TRUE if service key matches the pre-generated ones in service key
     * storage. FALSE for otherwise.
     */
    public boolean isServiceKeyValid( String serviceKey ) {
        return serviceKeysStorage.containsKey( serviceKey );
    }

    public void logout( String serviceKey, String authToken ) throws GeneralSecurityException {
        if ( serviceKeysStorage.containsKey( serviceKey ) ) {
            String usernameMatch1 = serviceKeysStorage.get( serviceKey );

            if ( authorizationTokensStorage.containsKey( authToken ) ) {
                String usernameMatch2 = authorizationTokensStorage.get( authToken );

                if ( usernameMatch1.equals( usernameMatch2 ) ) {

                    /**
                     * When a client logs out, the authentication token will be
                     * remove and will be made invalid.
                     */
                    authorizationTokensStorage.remove( authToken );
                    return;
                }
            }
        }

        throw new GeneralSecurityException( "Invalid service key and authorization token match." );
    }

    @Override
    public void filter(ContainerRequestContext requestContext) throws IOException {
        
        final MultivaluedMap headers = requestContext.getHeaders();
        serviceKey = headers.get(SERVICE_KEY).toString();
        username = headers.get(USERNAME).toString();
        password = headers.get(PASSWORD).toString();
        
        
        
    }
    
    public String isUserAuthenticate(HttpHeaders headers){
         serviceKey =  headers.getHeaderString(SERVICE_KEY);
         username = (String) headers.getHeaderString(USERNAME);
         password = (String) headers.getHeaderString(PASSWORD);
         try {
              authToken = getInstance().login(serviceKey, username, password);
          } catch (LoginException ex) {
              Logger.getLogger(AuthenticationFilter.class.getName()).log(Level.SEVERE, null, ex);
              authToken = ex.getLocalizedMessage();
          }
         return authToken;
        
    }
    
    public boolean isUserAuthorized( HttpHeaders headers){
         serviceKey = headers.getHeaderString(SERVICE_KEY);
         authToken = headers.getHeaderString("authToken");
         return isAuthTokenValid(serviceKey, authToken);        
    }

}
